## 简答题

#### 谈谈你是如何理解 JS 异步编程的，EventLoop、消息队列都是做什么的，什么是宏任务，什么是微任务？

**答:**

首先说说为什么会有`JS`异步编程
众所周知，`JS`是单线程模式工作的。因为`JS`是运行在浏览器端的脚本语言，目的是为了实现页面的交互，那么因为页面交互主要是DOM操作，从而决定了它必须使用单线程模式工作，否则就会出现特别复杂的线程同步问题。
这种模式优点是更安全、更简单，缺点就是如果在代码执行中遇到一个特别耗时的操作，那么后面的代码就必须等待这个操作结束以后才可以执行。
所以，为了解决像这样的情况，`JS`将任务的执行模式分成了两种，分别是**同步模式(Synchronous)**和**异步模式(Asynchronous)**

所以 `JS` 异步编程，它可以处理一些耗时操作，从而不会堵塞主线程。异步模式是通过**EventLoop**和**消息队列**去实现的。

**从代码层面直接分析梳理逻辑**
```js
console.log(1)
setTimeout(() => console.log(2), 0)
console.log(3)
Promise.resolve(4).then(v => console.log(v))
console.log(5)
```

当运行上面代码的时候，会生成一个执行上下文，然后会将这个执行上下文放入到执行环境栈中执行（以数字代表运行到第几行代码）
1. 为同步代码直接输出
2. 为异步代码会放入到消息队列中等待
3. 同步代码直接输出
4. 为异步代码放入消息队列中等待
5. 同步代码直接输出

到此，同步代码全部执行完毕，这个时候 EventLoop 事件循环就会工作，它会监听执行环境栈和消息队列中的任务，当执行环境栈中的任务结束以后，他会从查看消息队列中有没有等待执行任务，如果有，会依次取出等待执行的任务，重新放入执行环境栈中执行。然后继续循环，直至所有任务全部结束，才会停止工作。
那么上面代码会将第2行和第4的代码依次取出打印。
但这里又涉及到了宏任务和微任务
setTimeout 为宏任务，Promise 为微任务，在一次进程中，宏任务是要等待所有同步代码和微任务执行完成之后才会执行的
所以此段代码最终打印结果为 1 3 5 4 2

**宏任务和微任务**
宏任务会等待微任务执行结束以后才会执行

- 目前大部分异步调用都是作为宏任务执行的, 如：setTimeout…
- 作为微任务处理的有：Promise 和 MutationObserver 和 nodeJs中的 process.nextTick
