# Part1-2 作业

( 请在当前文件直接作答 )

## 简答题

### 1. 请说出下列最终执行结果，并解释为什么?

```javascript
var a = [];
console.log(i)
for(var i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i)
  }
}
a[6]()
```
答：打印结果为10
`var`声明的变量会存在变量提升，那么在`for`循环结束以后`i`已经变成了`10`，所以最后在调用函数的时候，打印的`i`是全局的`i`，这时`i`已经为`10`，所以无论是`a`数组中的任何一个调用，结果都为`10`

### 2. 请说出此案列最终执行结果，并解释为什么?

```javascript
var tmp = 123;
if (true) {
  console.log(tmp);
  let tmp;
}
```
答：会抛出异常为`Cannot access 'tmp' before initialization`，因为在ES6中定义了代码块的概念，所以`if`内部就形成了一个 代码块，拥有自己的作用域，在当前作用域中，`let`关键词声明的变量没有变量提升阶段，所以在声明之前去使用这个变量会直接抛出异常，初始化之前无法访问该变量

### 3. 结合ES6语法，用最简单的方式找出数组中的最小值

```javascript
var arr = [12, 34, 32, 89, 4]
// 答：
console.log(Math.min(...arr))
```

### 4. 请详细说明var、let、const三种声明变量的方式之间的具体差别
答：
- 变量提升
`var`声明的变量会有变量提升阶段，在声明前如果访问该变量值会是`undefined`；
`let`和`const`则没有变量提升阶段，如果在声明前访问该变量则会直接抛出异常（C`annot access 'xxx' before initialization`）
- 作用域
`var`声明的变量作用于全局作用域或函数作用域
`let`和`const`声明的变量作用于块级作用域
- 声明与赋值
`var`和`let`可以先声明后赋值
`const`则必须声明的同时就赋值
- 同一作用域下重复声明
`var`可以在同一作用域下重复声明同一变量，后面会将前面的覆盖；
`let`和`const`不可以在同一作用域下重复声明同一变量，否则会报错（I`dentifier 'xx' has already been declared`）
- 声明后数据是否可变
`var`和`let`声明的变量声明后数据可以随意改变
`const`声明的变量，如果是普通值，则不可以改变，如果是引用类型数据则不会改变对应的指针，内部的数据是可以改变的。

### 5. 请说出下列代码最终输出结果，并解释为什么？

```javascript
var a = 10;
var obj = {
  a: 20,
  fn() {
    setTimeout(() => {
      console.log(this)
      console.log(this.a)
    })
  }
}
obj.fn()
```
答：打印结果为`20`
因为箭头函数中没有`this`，那么调用`fn`时，定时器中的`this`则指向的是`obj`这个对象，所以`this.a`打印的就是`obj`中的`a`，即会打印出`20`。如果将定时器中的箭头函数换成普通`function`的话，则打印结果就为`10`了，因为这个时候的`this`指向的是`window`对象，在这里找`this.a`，找的就是全局下的`a`。

### 6. 简述Symbol类型的用途

答：主要作用就是为对象添加独一无二的属性名（可以定义私有的属性和方法，让外界无法访问到）
```js
Symbol() === Symbol() // false

const name = Symbol()
const person = {
    [name]: 'zs',
    say() {
        console.log(this[name])
    }
}
console.log(Object.keys(person)) // ['say']
```

### 7. 说说什么是浅拷贝，什么是深拷贝？
答：首先深浅拷贝是只针对引用数据类型的。
浅拷贝只复制指向某个对象的指针，即复制的是在栈中的地址，而不是堆中的数据，新旧对象还是共享同一块内存
深拷贝是会创建一个一模一样的对象，即复制的是堆中的数据，不共享内存，修改任何一个都不会影响另外一个

### 8. 请简述TypeScript与JavaScript之间的关系？
答: TS就是JS的超集。TS在JS的基础上多了一些特性（类型系统、ES6+新特性的支持），通过编译后生成JS。
任何一种JS的运行环境TS都支持。功能更强大，生态也更健全、更完善。

### 9. 请谈谈你所认为的typescript优缺点
答：首先说说ts的优点，ts增加了代码的可读性和可维护性；同时属于渐进式的。
支持纯js写法，学一点加一点，.js文件可以直接更改为.ts。
在编译阶段就可以抛出异常，总比运行时报错好。
再说说缺点：有挺大的学习成本，需要理解很多概念，如：接口，泛型，类，枚举等
同时也会增加一定的开发成本，需要多些很多类型定义的代码，但对于长期的项目，这样能减少很多的维护成本

### 10. 描述引用计数的工作原理和优缺点
答：核心思想就是，内部设置一个引用计数器，判断当前对象的引用数是否为0，如果为0的时候，GC会认定此对象为垃圾对象，然后立即对其进行回收，释放空间。引用计数器，当某一个对象的引用关系发生改变的时候，会主动的修改其身上的引用数字。
优点：发现垃圾时，立即进行回收。最大限度的减少程序的暂停。
缺点：无法回收循环引用的对象，时间开销大。

### 11. 描述标记整理算法的工作流程
答：在说标记整理算法之前先说说标记清除算法。核心思想就是将整个GC操作分为标记和清除两个阶段完成。第一个阶段会遍历所有的对象，找到活动对象进行标记。第二个阶段依然会遍历所有对象，然后清除所有没有被标记的对象，随后会将之前存在标记的对象身上的标记抹去。最后就收回相应的空间。
标记整理算法就是标记清除算法的增强。标记阶段的操作同标记清除一致，在清除阶段会先执行整理操作，移动对象位置，最后进行回收。这样就避免了出现碎片化的空间。

### 12.描述V8中新生代存储区垃圾回收的流程
答：新生代存储区会分为两块等大的空间（to，from），在64位操作系统中会有32M，32位操作系统会有16M的内存大小，这里是用来存放存活时间较短的对象。回收的过程采用的是复制算法和标记整理算法。（from空间位使用空间，to空间为空闲空间），活动对象存储于from空间，触发GC机制后，使用标记整理算法将活动对象拷贝至to空间，from与to空间进行交换，然后释放to空间，就实现了垃圾回收。
拷贝过程中可能会出现晋升，某一个对象指向的空间在老年代中也存在的时候，则会出现晋升，将其移动至老年代。
如果新生代中某些对象经过一轮GC后还存在，或者当前拷贝过程中to空间的使用率超过25%的时候也同样会将其移动至老年代中。

### 13. 描述增量标记算法在何时使用及工作原理
答：增量标记算法是优化垃圾回收的操作。GC操作是会阻碍程序的执行。
将当前一整段垃圾回收操作，拆分成多个小步，组合完成整个垃圾回收操作，去替代之前一口气做完整段垃圾回收操作。可以实现垃圾回收和程序执行去交替执行。
程序在运行的时候，当触发了GC时，遍历对象进行标记，可以不一口气做完，因为可达对象分为直接可达和间接可达。第一次先找出第一层直接可达对象，然后暂停GC，让程序继续执行，随后再暂停程序，继续GC标记，依次交替。最终完成清除操作，释放空间。
　